// server/controllers/problemsController.js

const OpenAI = require('openai');
const validator = require('validator');
const logger = require('../utils/logger');
const { body, validationResult } = require('express-validator');

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY, // Ensure this is correctly set in .env
});

// Function to extract JSON from possible code blocks
const extractJSON = (content) => {
  const regex = /```json\s*([\s\S]*?)\s*```/;
  const match = content.match(regex);
  if (match) {
    return match[1];
  }
  return content;
};

// Handler for POST /api/analyze
const analyzeProblem = [
  // Validation Middleware
  body('problemText')
    .isString()
    .withMessage('Problem text must be a string.')
    .isLength({ min: 1, max: 1000 })
    .withMessage('Problem text must be between 1 and 1000 characters.'),

  // Main Handler
  async (req, res) => {
    // Handle Validation Results
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      logger.warn('Validation failed:', JSON.stringify(errors.array()));
      return res.status(400).json({ errors: errors.array() });
    }

    let { problemText } = req.body;

    // Sanitize the input
    problemText = validator.escape(problemText);

    try {
      logger.info('Analyzing problem:', problemText);

      // Step 1: Analyze the Problem
      const analysisPrompt = `
      Analyze the following math problem to determine its type (e.g., Algebra, Calculus, Geometry),subtype(Subtopic of maintype(e.g. eigenvectors)) and difficulty level (e.g., Easy, Medium, Hard).

      Problem:
      "${problemText}"

      Respond **only** with a plain JSON object in the following format without any markdown, code blocks, or additional text:

      {
        "type": "Algebra",
        "subtype": "Linear Equations",
        "difficulty": "Medium"
      }
      `;

      const analysisResponse = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{ role: 'user', content: analysisPrompt }],
        temperature: 0.5,
      });

      // **Extract and Clean the JSON**
      let analysisResultRaw = analysisResponse.choices[0].message.content.trim();
      analysisResultRaw = extractJSON(analysisResultRaw);

      logger.info('Received analysisResult:', analysisResultRaw);

      let analysis;
      try {
        analysis = JSON.parse(analysisResultRaw);
      } catch (error) {
        logger.error('Failed to parse analysisResult as JSON:', analysisResultRaw);
        return res.status(500).json({ error: 'Failed to parse analysis result.', details: analysisResultRaw });
      }

      const { type, difficulty } = analysis;

      if (!type || !difficulty) {
        logger.error('Incomplete analysis:', JSON.stringify(analysis));
        return res.status(500).json({
          error: 'Incomplete analysis from OpenAI.',
          details: analysis,
        });
      }

      // Step 2: Generate Similar Problems
      logger.info(`Generating similar problems for type: ${type}, difficulty: ${difficulty}`);
      const generationPrompt = `
      Generate five math problems similar in type (${type}) and difficulty (${difficulty}) to the following problem:

      "${problemText}"

      Provide the problems as a plain JSON array without any markdown, code blocks, or additional text:

      [
        "Problem 1",
        "Problem 2",
        "Problem 3",
        "Problem 4",
        "Problem 5"
      ]
      `;

      const generationResponse = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{ role: 'user', content: generationPrompt }],
        temperature: 0.7,
      });

      let generationResultRaw = generationResponse.choices[0].message.content.trim();
      generationResultRaw = extractJSON(generationResultRaw);

      logger.info('Received generationResult:', generationResultRaw);

      let similarProblems;
      try {
        similarProblems = JSON.parse(generationResultRaw);
      } catch (error) {
        logger.error('Failed to parse generationResult as JSON:', generationResultRaw);
        return res.status(500).json({ error: 'Failed to parse similar problems.', details: generationResultRaw });
      }

      if (!Array.isArray(similarProblems) || similarProblems.length === 0) {
        logger.error('Invalid similarProblems:', JSON.stringify(similarProblems));
        return res.status(500).json({
          error: 'Invalid similar problems generated by OpenAI.',
          details: similarProblems,
        });
      }

      // Step 3: Provide Step-by-Step Solution
      const solutionPrompt = `
      Provide a detailed, step-by-step solution to the following math problem.

      Problem:
      "${problemText}"

      Solution:
      `;

      const solutionResponse = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{ role: 'user', content: solutionPrompt }],
        temperature: 0.5,
      });

      const solution = solutionResponse.choices[0].message.content.trim();

      logger.info('Received solution:', solution);

      // Respond with Analysis, Similar Problems, and Solution
      logger.info('Successfully processed analyze request.');
      res.json({
        type,
        difficulty,
        similarProblems,
        solution,
      });
    } catch (error) {
      if (error instanceof OpenAI.APIError) {
        // Handle OpenAI API errors
        logger.error(`OpenAI API Error: ${error.message}`);
        return res.status(error.status).json({
          error: error.message,
          code: error.code,
          type: error.type,
        });
      } else {
        // Handle other errors
        logger.error(`Error processing /api/analyze request: ${error.message}`);
        res.status(500).json({ error: 'An error occurred while processing your request.' });
      }
    }
  },
];

module.exports = {
  analyzeProblem,
};
